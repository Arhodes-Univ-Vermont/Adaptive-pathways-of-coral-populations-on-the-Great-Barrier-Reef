// version 3: 
// - instead of heritability there is added random error with constant SD ("esd")
// (environmental effect on top of genetics);
// - fitness has low limit ("fitcushion") to stabilize behavior when fitness is very low;
// - pop size scaling switches on at generation 1500 (500 gens before warming);
// - hermaphroditic selfing is prohibited

initialize() {
	setSeed(1);
	defineConstant("startTime",clock()); 
	
	defineConstant("migMatrix","./10reefs.txt");  // path and filename containing migration matrix with pop sizes on diagonal; rows are sources, columns are sinks
	defineConstant("Environment","./10reefs__environment.txt");  // path and filename containing environmental conditions: rows are populations, columns are generations
	initializeSLiMOptions(preventIncidentalSelfing=T);
	initializeMutationRate(1e-6); 
	
	defineConstant("esd",1.0);				// sd of environmental effect on fitness, on top of genetic
	defineConstant("pl",1.0);				// plasticity: SD of the bell curve defining stabilizing selection regime
	defineConstant("mutEffect",0.2);		// SD of mutation effects at QTLs (mean=0)
	defineConstant("C", 10);				// number of QTLs
	defineConstant("N", 1);					// number of unlinked neutral sites (for popgen)

	defineConstant("migFactor",1);		// power factor for migration rate scaling
	defineConstant("maxfit",dnorm(0.0,0.0,pl));	// height of N peak, for fitness scaling
	defineConstant("fitcushion",0.0005);	// lowest possible fitness

	// neutral mutations in non-coding regions
	initializeMutationType("m1", 0.5, "f", 0.0);					// neutral
	initializeMutationType("m2", 0.5, "n", 0, mutEffect);		// thermal QTL
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElementType("g2", m2, 1.0);
	m2.convertToSubstitution = F;
	initializeGenomicElement(g1,0,C-1);
	initializeGenomicElement(g2,C,C+N-1);
	initializeRecombinationRate(0.5);
	m2.mutationStackPolicy = "s"; // new mutations add to previous ones at the same locus
}

// reading the tab-delimited migration rates matrix with pop sizes on diagonal 
// (no header!)
// sources are rows, sinks are columns
1 early() { 
	migrations=readFile(migMatrix);
	defineConstant("npops",size(migrations));
	
	// scan the file once to get pop sizes
	popsizes=NULL;
	
	for (p in 0:(npops-1)){
//		print("-----------");
		ms=strsplit(migrations[p],sep="\t");
		
//		print(paste(c("\tpopsize",p,"=",ms[p]),sep=""));
		popsizes=c(popsizes,asInteger(ms[p]));
	}
	sim.setValue("popsizes",popsizes);
	
	// make our subpopulations
	for (p in 0:(npops-1)){
		sim.addSubpop(p, popsizes[p]);
	}
	sim.setValue("deadpops",rep(0,npops));

	// scan the file again to get and set migration rates
	for (p in 0:(npops-1)){
//		print("-----------");
		ms=asFloat(strsplit(migrations[p],sep="\t"));
		sim.subpopulations[p].setValue("popmig", ms);
		
		for (m in 0:(npops-1)) {
			if (m!=p) { 
//				print(paste(c("m",m,"_",p,"=",ms[m]),sep=""));
				sim.subpopulations[m].setMigrationRates(sim.subpopulations[p],ms[m]);
			}
		}
	}
}

// load environmental profiles: tab-delimited table with generations as columns, pops as rows. Header line must be present but what it contains is irrelevant.
1 early() { 
	env=readFile(Environment); // Environment constant is defined earlier
	for (i in 0:(npops-1)) {
		sim.setValue(paste(c(i,".env"),sep=""),asFloat(strsplit(env[i+1],sep="\t"))); 
	}
	
	// create specific fitness callbacks for each subpop and generation
	// note that SLiM now optimizes this exact callback structure, so it is kind of "magic" and will be slower if it is changed at all
	for (i in 0:(npops-1)) {
		envValues = sim.getValue(paste(c(i,".env"),sep=""));
		for (gen in 1:2400)	// there are 2500 values but we want to go only to gen 2400 according to the model
		{
			env = envValues[gen];
			src = "{ return " + fitcushion + " + " + "dnorm(" + env + " - individual.tagF, 0.0, " + pl + ") / " + (maxfit / (1 - fitcushion)) + "; }";
			sim.registerFitnessCallback(NULL, src, NULL, i, gen, gen);
		}
	}
}


1 late() {	// give m2 and m mutations to everyone, as standing variation
	// if this is commented out, QTLs effectively start as 0
	g = sim.subpopulations.genomes;	n = size(g);
//	print(n);
	for (q in 1:C)	{
		effects = rnorm(n, 0, mutEffect);
		for(ii in 0:(n-1)) {
			g[ii].addNewMutation(m2, effects[ii], q-1); 
		}
	} 
	// give m1 (neutral) mutations to everyone
	for (p in (C+1):(C+N))	{
		for(ii in 0:(n-1)) {
			g[ii].addNewMutation(m1, 0.0, p-1); 
		}
	} 
}

// QTL machinery:

1: late() {
	// construct phenotypes for the additive effects of QTLs plus random noise (controlled by esd parameter)
	inds = sim.subpopulations.individuals;
	inds.tagF = inds.sumOfMutationsOfType(m2) + rnorm(size(inds),0,esd);
}
fitness(m2) { 
	// the QTLs themselves are neutral
		return 1.0;
}

// output fitness and phenotypes
2: early() {
	for (i in 0:(size(sim.subpopulations)-1)){
		pop=sim.subpopulations[i];
		cat(sim.generation +"\t" + i +"\t"+mean(pop.cachedFitness(NULL))+ "\t" + mean(pop.individuals.tagF) + "\n");
	}
}

//2:5 late(){
//	el=(clock()-startTime)/3600;
//	cat("#"+sim.generation+":"+el+" hours elapsed\n");
//}

// calculating pop size scaling factors depending on mean fitness acheved over generations 1490-1500
1490 late() {
 sim.setValue("ps", rep(0, size(sim.subpopulations)));
}
1491:1500 late() {
 means = apply(sim.subpopulations,"mean(applyValue.cachedFitness(NULL));");
 sim.setValue("ps", sim.getValue("ps") + means);
 sim.setValue("fc", rep(1.0, size(sim.subpopulations)));
	if (sim.generation==1500){	
		fc=sim.getValue("fc");
		for (i in 0:(size(sim.subpopulations)-1)) {
			fc[i]=sim.getValue("ps")[i]/10;
		}
		sim.setValue("fc",fc);
	}
}

// output all mutations post-burnin
1999 late() { 
		sim.outputMutations(sim.mutationsOfType(m2));
}

// scaling pop size based on fitness post generation 1500
1501: early() {
	subpops = sim.subpopulations;
	popsizes = sim.getValue("popsizes");
	deadpops=sim.getValue("deadpops");
	for (i in 0:(size(subpops)-1)) {
		pop=subpops[i];
		popsize = popsizes[i];
		meanFitness = mean(pop.cachedFitness(NULL));
		if (meanFitness<2*fitcushion & deadpops[i]==0) {
	      	  	deadpops[i]=1;
			sim.setValue("deadpops",deadpops);
	          	cat("#"+sim.generation+"\t"+i+"\textinct.\n");
		}
		if (sum(deadpops)==size(subpops)) {
//	          	cat("#"+sim.generation+"\t"+"ALL\textinct.\n");
	          	sim.simulationFinished();
		}
		newSize = asInteger(10+popsize * meanFitness / sim.getValue("fc")[i]);
		newSize = asInteger(10+popsize * meanFitness / sim.getValue("fc")[i]);
		pop.setSubpopulationSize(newSize);
		scaledMig = pop.getValue("popmig") * (newSize/popsize)^migFactor; 
		if (newSize<popsize){
			for (j in 0:(size(subpops)-1))
				if (i != j) {
//					cat(i + ","+j+" size:"+newSize+" rate:"+scaledMig[j]+"\n");
					if(scaledMig[j]<1e-7) { scaledMig[j]=0; }
					subpops[j].setMigrationRates(pop, scaledMig[j]); 
				}
		}
	}
}

2400 late() {} 

