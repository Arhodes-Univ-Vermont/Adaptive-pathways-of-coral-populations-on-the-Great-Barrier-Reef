initialize() { 
	defineConstant("migMatrix","/Users/c-monstr/Documents/SLiM_adaptation_metapop_variableSelection_Dec2016/SLiM_fileReading/migrationMatrix_noBS.txt");  // path and filename containing migration matrix with pop sizes on diagonal; rows are sources, columns are sinks
	defineConstant("Environment","/Users/c-monstr/Documents/SLiM_adaptation_metapop_variableSelection_Dec2016/SLiM_fileReading/sim_environment.txt");  // path and filename containing environmental conditions: rows are populations, columns are generations
	initializeMutationRate(0); // 1e-7 : 5-fold the per-base mutation rate. 105,000 inds x 2 genomes x 20 QTLs = 4e+6 loci to mutate. Rate 1e-7 => 0.4 new QTL mutations per generation.
	defineConstant("h2",0.5); // heritability: proportion of phenotypic variaton explained by genetics
	defineConstant("pl",2.0); // plasticity: SD of the bell curve defining stabilizing selection regime
	defineConstant("mutEffect",0.2); // SD of mutation effects at QTLs (mean=0)
	defineConstant("C", 10); // number of QTLs
	defineConstant("N", 1); // number of unlinked neutral sites (for popgen)
	defineConstant("increment",0.05); // increment in optimum per generation past genereation 1000 (1 degree in 100 yr, 5 yr per generations => 0.05 per generation)

	defineConstant("migFactor",1); // power factor for migration rate scaling
	defineConstant("maxfit",dnorm(0.0,0.0,pl)); // height of N peak, for fitness scaling

	// neutral mutations in non-coding regions
	initializeMutationType("m1", 0.5, "f", 0.0); // neutral
	initializeMutationType("m2", 0.5, "n", 0, mutEffect); // thermal QTL
	initializeMutationType("m3", 0.5, "f", 0.0); // fitness handler
	initializeGenomicElementType("g1", m1, 1.0); 
	initializeGenomicElementType("g2", m2, 1.0); 
	initializeGenomicElementType("g3", m3, 1.0); 
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "f"; // prohibiting new mutations from taking effect (for burn-in period)
	m3.convertToSubstitution = F;
	initializeGenomicElement(g3,0,0);
	initializeGenomicElement(g1,1,C);
	initializeGenomicElement(g2,C+1,C+N);
	initializeRecombinationRate(0.5);
}

2001 early() {
	m2.mutationStackPolicy = "s"; // stacking new mutations after burn-in
}

// readng the tab-delimited migration rates matrix with pop sizes on diagonal 
// sources are rows, sinks are columns
1 early() { 
	migrations=readFile(migMatrix);
	defineConstant("npops",size(migrations));
	popsizes=c();
	migrates=c();
	mignames=c();
	for (p in 0:(npops-1)){
//		print("-----------");
		ms=strsplit(migrations[p],sep="\t");		
		for (m in 0:(npops-1)) {
			if (m==p) { 
//				print(paste(c("\tpopsize",p,"=",ms[m]),sep=""));
				popsizes=c(popsizes,asInteger(ms[m]));
			}
			else {
//				print(paste(c("m",m,p,"=",ms[m]),sep=""));
				migrates=c(migrates,asFloat(ms[m]));
				mignames=c(mignames,paste(c("m",m,p),sep=""));
			}
		}
	}
	sim.setValue("popsizes",popsizes);
	sim.setValue("migrates",migrates);
	sim.setValue("mignames",mignames);
	
	for (p in 0:(npops-1)){
		sim.addSubpop(paste(c("p",p),sep=""), popsizes[p]);
	}
	for (i in 0:(npops-1)){
		for (j in 0:(npops-1)){
			if( i!=j) {
sim.subpopulations[i].setMigrationRates(sim.subpopulations[j],migrates[mignames==paste(c("m",i,j),sep="")]);
			}
		}
	}
}

// load environmental profiles: tab-delimited table with generations as columns, pops as rows. Header line must be present but what it contains is irrelevant.
1 early() { 
	env=readFile(Environment); // Environment constant is defined earlier
	for (i in 0:(npops-1)) {
		sim.setValue(paste(c(i,".env"),sep=""),asFloat(strsplit(env[i+1],sep="\t"))); 
	}
}


1 late() {	// give m2 and m mutations to everyone, as standing variation
	// if this is commented out, QTLs effectively start as 0
	g = sim.subpopulations.genomes;	n = size(g);
//	print(n);
	for (q in 1:C)	{
		for(ii in 0:(n-1)) {
			g[ii].addNewMutation(m2, rnorm(1,0,mutEffect), q); 
		}
	} 
	// give m1 (neutral) mutations to everyone
	for (p in (C+1):(C+N))	{
		for(ii in 0:(n-1)) {
			g[ii].addNewMutation(m1, 0.0, p); 
		}
	} 
}

// QTL machinery:

1 late() {	// give an m3 mutation to every individual, for phenoty(2*PI)c fitness 
	sim.subpopulations.genomes.addNewMutation(m3, 0.0, 0);
}

1: late() {
	// construct phenotypes for the additive effects of QTLs
	tags=asFloat(NULL);
	for (individual in sim.subpopulations.individuals)
	{
		m2muts = individual.genomes.mutationsOfType(m2); 
		tags=c(tags,asFloat(sum(m2muts.selectionCoeff)));
	} 
	mb=mean(tags);
	sdb=sd(tags);
//	h22=h2;
//	if (size(tags)<10) { h22=1;} // just to make post-extinction fitness values stable under low h2
	if (sdb<0.1) { sdb=0.1;}
	bs=tags-mb;
	bs=bs/sdb;
	z=sqrt(h2)*bs+sqrt(1-h2)*rnorm(size(tags),0,1);	
	pheno=z*sdb+mb;
	i=0;
	for (individual in sim.subpopulations.individuals)	{
		individual.setValue("phenotype",pheno[i]);
		i=i+1;
	}
//	print(c("\n-------\ntags:",tags,"\npheno:",pheno));

}
fitness(m2) { 
	// the QTLs themselves are neutral; the m3 mutation type handles them
		return 1.0;
}


// setting  fitness function accoriding to the stored environmental conditions and phenotypes
1: fitness(m3) {
	phenotype=individual.getValue("phenotype");		
	Env=sim.getValue(paste(c(subpop.id,".env"),sep=""))[sim.generation];
	return dnorm(Env - phenotype, 0.0, pl)/maxfit; 
}


// output
1500: early() {
	for (i in 0:(size(sim.subpopulations)-1)){
		pop=sim.subpopulations[i];
		cat(sim.generation +"\t" + i +"\t"+mean(pop.cachedFitness(NULL))+ "\t" + mean(pop.individuals.getValue("phenotype")) + "\n");
	}
}

// calculating pop size scaling factors depending on mean fitness acheved over last 10 generations of burnin
1991 late() {
 sim.setValue("ps", rep(0, size(sim.subpopulations)));
}
1991:2000 late() {
 means = apply(sim.subpopulations,"mean(applyValue.cachedFitness(NULL));");
 sim.setValue("ps", sim.getValue("ps") + means);
 sim.setValue("fc", rep(1.0, size(sim.subpopulations)));
	if (sim.generation==2000){	
		fc=sim.getValue("fc");
		for (i in 0:(size(sim.subpopulations)-1)) {
			fc[i]=sim.getValue("ps")[i]/10;
		}
		sim.setValue("fc",fc);
		sim.outputMutations(sim.mutationsOfType(m2));
	}
//	print(sim.getValue("fc"));
}

// scaling pop size based on fitness post burn-in
2001: early() {
	for (i in 0:(size(sim.subpopulations)-1)) {
		pop=sim.subpopulations[i];
		meanFitness = mean(pop.cachedFitness(NULL));
		newSize = asInteger(1+sim.getValue("popsizes")[i] * meanFitness / sim.getValue("fc")[i]);
		pop.setSubpopulationSize(newSize);
		for (j in 0:(size(sim.subpopulations)-1)) {	
			if (i != j) sim.subpopulations[j].setMigrationRates(sim.subpopulations[i], sim.getValue("migrates")[sim.getValue("mignames")==paste(c("m",j,i),sep="")]*((newSize/sim.getValue("popsizes")[i])^migFactor)); 
		}
	}
}

2400 late() {} 
